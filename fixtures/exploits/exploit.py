"""
Provides exploit related classes

"""

from collections import defaultdict
import csv
from enum import Enum

from structs import RiskLevel
from tools.nmap.protocols_list import NMAP_PROTOCOLS
from tools.nmap.services_list import NMAP_SERVICES
from utils.exceptions import ServiceUnsupportedByNmapException, PortUnsupportedException, \
    ProtocolUnsupportedByNmapException, PortRangeUnsupported


class ExploitCategory(Enum):
    """
    Exploits categories

    """
    AUTH = 'auth'
    BRUTE = 'brute'
    DOS = 'dos'
    EXPLOIT = 'exploit'
    EXTERNAL = 'external'
    FUZZER = 'fuzzer'
    INTRUSIVE = 'intrusive'
    MALWARE = 'malware'
    SAFE = 'safe'
    VERSION = 'version'
    VULN = 'vuln'
    OTHER = 'other'


class ExploitMetric(Enum):
    """
    Exploits metrics

    """

    AFP = 'AFP'
    AJP = 'AJP'
    AMQP = 'AMQP'
    BROADCAST = 'Broadcast'
    CASSANDRA = 'Cassandra'
    CITRIX = 'Citrix'
    COUCHDB = 'CouchDB'
    CUPS = 'CUPS service and queue info'
    CVE_SEARCH = 'CVE-Search'
    DISTCC = 'distcc'
    DNS = 'DNS SRV enumeration and zone transfer'
    DOCKER = 'Docker'
    EAP = 'EAP'
    FTP = 'FTP'
    HADOOP = 'Hadoop'
    HTTP_CISCO_ASA = 'Cisco ASA HTTP management application'
    HTTP_CREDS = 'Using default login credentials'
    HTTP_FINGERPRINT = 'Web application name and version detection'
    HTTP_HEADERS = 'HTTP headers - if they are properly configured or not'
    HTTP_INFO = 'HTTP vulnerabilities'
    HTTP_PATH_ENUM = 'Path enumeration'
    HTTP_PROXY = 'HTTP Proxy'
    HTTP_SLOWLORIS = 'Slowloris Dos attack'
    HTTP_VULNS = 'Specific HTTP vulnerabilities (for PHP Ruby server IIS Apache JBoss Websphere and so on)'
    HYDRA = 'Hydra'
    IKE = 'IKE'
    IMAP = 'IMAP info'
    IPMI_BRUTE = 'Bruteforce'
    IPMI_DUMP = 'Dump password hashes'
    IPMI_OTHER = 'IPMI'
    IPMI_ZERO = 'Cipher Zero Authentication Bypass'
    IRC = 'IRC'
    ISCSI = 'ISCSI'
    LDAP = 'LDAP searching and retrieving DSE'
    MAIL_HEAP_OFLOW = 'Heap overflow'
    MAIL_MEM_CORRUPT = 'Memory corruption'
    MAIL_POP3 = 'POP3'
    MAIL_POSTFIX = 'Postfix closing'
    MEMCACHEDB = 'Memcache db'
    MONGODB = 'Mongodb information and databases'
    MSSQL_DUMP = 'Dump passwords and determine configuration from MS SQL'
    MYSQL = 'MySQL'
    NFS = 'NFS exports information'
    NTP = 'NTP information'
    PPTP = 'PPTP'
    QUAKE = 'Quake'
    RDP = 'RDP encryption and MS12-02 vulnerability'
    REDIS = 'Redis information'
    RMI = 'RMI'
    SAMBA_BUFF_OFLOW = 'Buffer overflow (ms06-025 ms07-029)'
    SAMBA_ENUM = 'Domains shares and session enumeration'
    SAMBA_OTHER = 'Samba'
    SAMBA_RCE = 'Remote code execution (ms08-067 WannaCry)'
    SKIPFISH = 'Skipfish'
    SNMP_CISCO = 'Obtaining Cisco router configuration'
    SNMP_ENUM = 'Enumerating Windows shares users services and installed software'
    SNMP_STATS = 'Getting netstat and processes from device'
    SSH_CCS = 'CCS injection'
    SSH_CERT = 'Certificate validation'
    SSH_ENUM = 'Algorithms enumeration'
    SSH_SUPPORTED = 'Checking for supported SSL versions and Diffie-Hellman groups'
    SSL_HEARTBLEED = 'Heartbleed'
    SSL_POODLE = 'Poodle'
    TNS = 'TNS'
    UPNP = 'UPNP'
    VNC_BYPASS = 'Bypassing RealVNC'
    VNC_INFO = 'RPC and VNC information'
    WINDOWS = 'Windows exploitation'
    XMPP = 'XMPP information'
    OTHER = ''


class Exploit(object):
    """
    Represents Exploit

    """
    def __init__(self, exploit_id, app=None, name=None, title=None, description=None, risk_level=None, services=None,
                 ports=None, categories=None, cve=None, metric=None):
        """

        Args:
            exploit_id (int): exploit id
            app (str): app name, e.g. nmap
            name (str): exploit name, e.g. http-enum
            title (str): title of exploit
            description(str): short description of exploit
            risk_level (RiskLevel): risk level
            services (list): supported services
            ports (list): supported ports
            categories (set): exploit's categories

        """
        self.id = exploit_id
        self.app = app
        self.name = name
        self.title = title
        self.description = description
        self.risk_level = risk_level
        self.services = services or set()
        self.ports = ports or {}
        self.categories = categories or set()
        self.metric = metric if metric is not None else ExploitMetric.OTHER
        self.cve = cve

    def __eq__(self, other):
        return isinstance(other, Exploit) and self.id == other.id

    def __ne__(self, other):
        return (not isinstance(other, Exploit)) or self.id != other.id

    def __hash__(self):
        return hash(self.id)


class Exploits(object):
    """
    Collection of exploits

    """

    def __init__(self):
        self._exploits = defaultdict(dict)
        self._all_exploits = set()

    def __iter__(self):
        """
        Implements iteration over exploits in collection

        Returns:
            Exploit

        """
        return iter(self._all_exploits)

    def add(self, exploit):
        """
        Add exploit to collection

        Args:
            exploit (Exploit):

        Returns:
            None
        """
        self._exploits[exploit.app][exploit.name] = exploit
        self._all_exploits.add(exploit)

    def find(self, app, name):
        """
        Find all exploits of provided name and app name

        Args:
            app (str):
            name (str):

        Returns:
            Exploit

        """
        return self._exploits[app].get(name)

    def find_all_matching(self, port=None):
        """
        Find all exploits meet the criteria

        Args:
            port (Port): Port, which we want to exploit

        Returns:
            list: all exploits for which:
                - app is equal
                - there is no port or service is equal or transport protocol and port is equal
                - there is no supported ports and services (exploit support all ports and services)

        """
        return_value = {}
        for exploit in self._all_exploits:
            if not port or port.protocol in exploit.services or \
                    (port.transport_protocol.db_val in exploit.ports.keys() and
                     port.number in exploit.ports[port.transport_protocol.db_val])or \
                    (not exploit.ports and not exploit.services):

                return_value.setdefault(exploit.app, []).append(exploit)

        return return_value

    def find_all_phy(self):
        """
        Finds all exploits for physical interface scanning

        Returns:
            list

        """
        return_value = {}
        for exploit in self._all_exploits:
            if "PHY" in exploit.ports.keys():
                return_value.setdefault(exploit.app, []).append(exploit)
        return return_value

    def remove(self, exploit):
        """
        Removes exploit from collection

        Args:
            exploit (Exploit):

        Returns:
            None

        """
        self._all_exploits.remove(exploit)
        self._exploits.get(exploit.app, {}).pop(exploit.name, None)

    @classmethod
    def read(cls, file_name):
        """
        Reads csv exploits database, and return collection of exploits

        Args:
            file_name:

        Returns:
            Exploits: collection of exploits

        """
        result = cls()

        with open(file_name, newline='', encoding='utf-8') as csvfile:
            reader = csv.reader(csvfile, delimiter=';', quotechar='"')
            for num, row in enumerate(reader):
                if num == 0:
                    continue #header
                exploit = Exploit(exploit_id=int(row[0]))
                exploit.app = row[1]
                exploit.name = row[2]
                exploit.title = row[3]
                exploit.description = row[4]
                exploit.risk_level = RiskLevel.from_name(row[5])
                exploit.services = cls.parse_services(row[6])
                exploit.ports = cls.parse_ports(row[7])
                exploit.categories = cls.parse_categories(row[8])
                exploit.cve = row[9]
                exploit.metric = ExploitMetric[row[10].upper()]
                result.add(exploit)
        return result

    @classmethod
    def parse_services(cls, text):
        """
        This function parses service string and returns list of services

        Args:
            text (str):

        Returns:
            list

        """
        if not text:
            return set()

        return_value = set()
        for service in text.split(','):
            service_name = service.strip()
            if service_name not in NMAP_SERVICES:
                raise ServiceUnsupportedByNmapException(service_name)
            return_value.add(service_name)

        return return_value

    @classmethod
    def parse_ports(cls, text):
        """
        This function parses port string and returns list of Ports

        Args:
            text (str):

        Returns:
            list

        """

        if not text:
            return {}

        return_value = {}
        protocols = text.split(",")
        ports = [protocol.split(":") for protocol in protocols]

        try:
            for protocol, port_set in ports:
                protocol = protocol.strip()
                if protocol not in NMAP_PROTOCOLS:
                    raise ProtocolUnsupportedByNmapException(protocol)
                return_value[protocol] = set()

                all_ports = port_set.split(".")
                for port in all_ports:
                    if "-" in port:
                        port_range = [int(port_number) for port_number in port.split("-")]
                        if port_range[0] >= port_range[1]:
                            raise PortRangeUnsupported(port)

                        return_value[protocol].update(range(int(port_range[0]), int(port_range[1]) + 1))
                        continue
                    return_value[protocol].add(int(port))
        except ValueError:
            raise PortUnsupportedException(text)

        return return_value

    @classmethod
    def parse_categories(cls, text):
        """

        Args:
            text:

        Returns:
            set

        """
        if not text:
            return {ExploitCategory.OTHER}

        return {ExploitCategory[cat.upper()] for cat in text.split(",")}

    def find_by_apps(self, apps):
        """
        Find all exploits for given apps list

        Args:
            apps (list):

        Returns:
            dict: {app: exploits, ...)

        """
        return {app: list(self._exploits.get(app, {}).values()) for app in apps}
