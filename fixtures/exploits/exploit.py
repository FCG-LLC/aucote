from collections import defaultdict
import csv
from os import path
from structs import RiskLevel
from tools.nmap.protocols_list import NMAP_PROTOCOLS
from tools.nmap.services_list import NMAP_SERVICES
from utils.exceptions import ServiceUnsupporedByNmapException, PortUnsupportedException, \
    ProtocolUnsupporedByNmapException, PortRangeUnsupported


class Exploit(object):
    '''
    Represents Exploit
    '''
    def __init__(self, id=None, app=None, name=None, title=None, description=None, risk_level=None, services=None,
                 ports=None):
        '''

        Args:
            id: exploit id
            app: app name, e.g. nmap
            name: exploit name, e.g. http-enum
            title: title of exploit
            description: short description of exploit
            risk_level: risk level
            services: supported services
            ports: supported ports
        '''
        self.ports = ports
        self.id = id
        self.app = app
        self.name = name
        self.title = title
        self.description = description
        self.risk_level = risk_level
        self.services = services or set()
        self.ports = ports or {}


class Exploits(object):
    '''
    Collection of exploits
    '''

    def __init__(self):
        self._exploits = defaultdict(dict)
        self._all_exploits = set()

    def __iter__(self):
        return iter(self._all_exploits)

    def add(self, exploit):
        '''
        Add exploit to collection
        Args:
            exploit:

        Returns:

        '''
        self._exploits[exploit.app][exploit.name] = exploit
        self._all_exploits.add(exploit)

    def find(self, app, name):
        '''
        Find all exploits of provided name and app name
        Args:
            app:
            name:

        Returns:

        '''
        return self._exploits[app].get(name)

    def find_all_matching(self, port=None):
        """
        Find all exploits meet the criteria
        Args:
            port: Port, which we want to exploit
        Returns: all exploits for which:
            app is equal
            there is no port or service is equal or transport protocol and port is equal
            there is no supported ports and services (exploit support all ports and services)
        """
        return_value = {}
        for exploit in self._all_exploits:
            if not port or port.service_name in exploit.services or \
                    (port.transport_protocol.db_val in exploit.ports.keys() and
                             port.number in exploit.ports[port.transport_protocol.db_val])or \
                    (not exploit.ports and not exploit.services):

                if exploit.app not in return_value.keys():
                    return_value[exploit.app] = []
                return_value[exploit.app].append(exploit)

        return return_value

    @classmethod
    def read(cls, file_name):
        '''
        Reads csv exploits database, and return collection of exploits
        Args:
            file_name:

        Returns: collection of exploits
        '''
        result = cls()

        with open(file_name, newline='', encoding='utf-8') as csvfile:
            reader = csv.reader(csvfile, delimiter=';', quotechar='"')
            for num, row in enumerate(reader):
                if num == 0: continue #header
                exploit = Exploit()
                exploit.id = int(row[0])
                exploit.app = row[1]
                exploit.name = row[2]
                exploit.title = row[3]
                exploit.description = row[4]
                exploit.risk_level = RiskLevel.from_name(row[5])
                exploit.services = cls.parse_services(row[6])
                exploit.ports = cls.parse_ports(row[7])
                result.add(exploit)
        return result

    @classmethod
    def parse_services(cls, text):
        if not text:
            return set()

        return_value=set()
        for service in text.split(','):
            service_name = service.strip()
            if service_name not in NMAP_SERVICES:
                raise ServiceUnsupporedByNmapException(service_name)
            return_value.add(service_name)

        return return_value

    @classmethod
    def parse_ports(cls, text):

        if not text:
            return {}

        return_value = {}
        protocols = text.split(",")
        ports = [protocol.split(":") for protocol in protocols]

        try:
            for protocol, port_set in ports:
                protocol = protocol.strip()
                if protocol not in NMAP_PROTOCOLS:
                    raise ProtocolUnsupporedByNmapException(protocol)
                return_value[protocol] = set()

                all_ports = port_set.split(".")
                for port in all_ports:
                    if "-" in port:
                        port_range = [int(port_number) for port_number in port.split("-")]
                        if port_range[0] >= port_range[1]:
                            raise PortRangeUnsupported(port)

                        return_value[protocol].update(range(int(port_range[0]), int(port_range[1]) + 1))
                        continue
                    return_value[protocol].add(int(port))
        except ValueError:
            raise PortUnsupportedException(text)

        return return_value
